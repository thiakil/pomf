buildscript {
  repositories {
    jcenter()
    maven {
      name = "Fabric"
      url = "http://maven.fabricmc.net/"
    }
    maven {
      name "Modmuss50 Repository"
      url 'https://maven.modmuss50.me'
    }
  }
  dependencies {
    classpath "net.fabricmc:weave:+"
    classpath "commons-io:commons-io:1.4"
    classpath "com.google.guava:guava:19.0"
  }
}

def minecraft_version = "18w20c"
def pomfVersion = "${minecraft_version}"

def ENV = System.getenv()

if (ENV.BUILD_NUMBER) {
  pomfVersion = pomfVersion + "." + "${System.getenv().BUILD_NUMBER}"
}

def mappingsDir = file("mappings")
def cacheFilesMinecraft = file(".gradle/minecraft")
def mergedFile = file("${minecraft_version}-merged.jar")
def versionFile = new File(cacheFilesMinecraft, "${minecraft_version}.json")
def clientJar = new File(cacheFilesMinecraft, "${minecraft_version}-client.jar")
def serverJar = new File(cacheFilesMinecraft, "${minecraft_version}-server.jar")

import com.google.common.hash.Hashing
import com.google.common.io.Files

import groovy.json.JsonSlurper
import net.fabricmc.weave.CommandFindMappingErrors
import net.fabricmc.weave.CommandTinyify
import net.fabricmc.weave.merge.JarMerger
import org.apache.commons.io.FileUtils

import java.util.zip.GZIPOutputStream

boolean validateChecksum(File file, String checksum) {
  if (file != null) {
    def hash = Files.hash(file, Hashing.sha1())
    def builder = new StringBuilder()
    hash.asBytes().each {
      builder.append(Integer.toString((it & 0xFF) + 0x100, 16).substring(1))
    }
    return builder.toString().equals(checksum)
  }
  return false
}

task downloadVersionsManifest {
  //inputs.property "mc_ver", minecraft_version
  inputs.property "currenttime", new Date()
  def manifestFile = new File(cacheFilesMinecraft, "version_manifest.json")
  outputs.file(manifestFile)
  doLast {
    logger.lifecycle(":downloading minecraft versions manifest")
    FileUtils.copyURLToFile(new URL("https://launchermeta.mojang.com/mc/game/version_manifest.json"), manifestFile)
  }
}

task downloadWantedVersionManifest(dependsOn: downloadVersionsManifest){
  def manifestFile = downloadVersionsManifest.outputs.files.singleFile
  def manifest = new JsonSlurper().parseText(FileUtils.readFileToString(manifestFile))
  def manifestVersion = manifest.versions.stream().filter({ it.id.equals(minecraft_version) }).findFirst()

  //have to grab the release time as there's a current timestamp on each element?!
  inputs.property "releaseTime",  manifestVersion.isPresent() ? manifestVersion.get().releaseTime : -1

  outputs.file versionFile

  doLast {
    if (manifestVersion.isPresent() || versionFile.exists()) {

      if (manifestVersion.isPresent())
        FileUtils.copyURLToFile(new URL(manifestVersion.get().url), versionFile)
    } else {
      throw new RuntimeException("No version data for Minecraft version ${minecraft_version}")
    }
  }

}

task download(dependsOn: downloadWantedVersionManifest) {

  def version = versionFile.exists() ? new JsonSlurper().parseText(FileUtils.readFileToString(versionFile)) : null
  inputs.property "client_sha", version?.downloads?.client?.sha1
  inputs.property "server_sha", version?.downloads?.server?.sha1

  inputs.property "client_sha_match", clientJar.exists() && version?.downloads?.client?.sha1 && validateChecksum(clientJar, version.downloads.client.sha1)
  inputs.property "server_sha_match", serverJar.exists() && version?.downloads?.server?.sha1 && validateChecksum(serverJar, version.downloads.server.sha1)

  outputs.files(clientJar, serverJar)

  doLast {
    if (!versionFile.exists()){
      throw new RuntimeException("Can't download the jars without the ${versionFile.name} file!")
    }

    //reload in case it changed
    version = new JsonSlurper().parseText(FileUtils.readFileToString(versionFile))

    logger.lifecycle(":downloading minecraft jars")

    if (!clientJar.exists() || !validateChecksum(clientJar, version.downloads.client.sha1)) {
      logger.lifecycle(":downloading minecraft client")
      FileUtils.copyURLToFile(new URL(version.downloads.client.url), clientJar)
    }

    if (!serverJar.exists() || !validateChecksum(serverJar, version.downloads.server.sha1)) {
      logger.lifecycle(":downloading minecraft server")
      FileUtils.copyURLToFile(new URL(version.downloads.server.url), serverJar)
    }
  }
}

task mergeJars(dependsOn: download) {
  inputs.files download.outputs.files.files
  outputs.file(mergedFile)

  doLast {
    logger.lifecycle(":merging jars")
    def client = new FileInputStream(inputs.files.files.find {it.name.endsWith("-client.jar")})
    def server = new FileInputStream(inputs.files.files.find {it.name.endsWith("-server.jar")})
    def merged = new FileOutputStream(mergedFile)

    def jarMerger = new JarMerger(client, server, merged)
    jarMerger.merge()
    jarMerger.close()

    client.close()
    server.close()
    merged.close()
  }

}

task setupPomf (dependsOn: mergeJars) {

}

task pomf(dependsOn: setupPomf) {
  doLast {
    def cacheFilesEnigma = new File(".gradle/enigma")
    if (!cacheFilesEnigma.exists()) cacheFilesEnigma.mkdirs()

    def mavenMetadata = new File(cacheFilesEnigma, "maven-metadata.xml")
    def localEnigmaVersion = mavenMetadata.exists() ? new XmlSlurper().parseText(FileUtils.readFileToString(mavenMetadata)).versioning.release : ""

    logger.lifecycle(":downloading enigma metadata")
    FileUtils.copyURLToFile(new URL("http://maven.fabricmc.net/cuchaz/enigma/maven-metadata.xml"), mavenMetadata)

    def metadata = new XmlSlurper().parseText(FileUtils.readFileToString(mavenMetadata))
    def enigmaVersion = metadata.versioning.release

    def enigma = new File(cacheFilesEnigma, "${enigmaVersion}.jar")

    if (localEnigmaVersion != enigmaVersion || !enigma.exists()) {
      logger.lifecycle(":downloading enigma")
      FileUtils.copyURLToFile(new URL("http://maven.fabricmc.net/cuchaz/enigma/${enigmaVersion}/enigma-${enigmaVersion}-all.jar"), enigma)
    } else {
      logger.lifecycle(":skipping enigma download")
    }

    logger.lifecycle(":launching enigma")
    ant.java(jar: enigma.getAbsolutePath(), fork: true, spawn: true) {
      arg(value: mergedFile.getAbsolutePath())
      arg(value: mappingsDir.getAbsolutePath())
    }
  }
}

task build(type: Zip) {
  from mappingsDir
  include "**/*"
  archiveName "pomf-enigma-${pomfVersion}.zip"
  destinationDir(file("build/libs"))
}

task checkMappings {
  inputs.dir mappingsDir
  doLast {
    logger.lifecycle(":checking mappings")

    String[] args = [
            mergedFile.getAbsolutePath(),
            mappingsDir.getAbsolutePath()
    ]

    new CommandFindMappingErrors().run(args)
  }
}

task buildTiny(dependsOn: "mergeJars") {
  inputs.dir mappingsDir
  def libs = new File("build/libs/")
  def outputFile = new File(libs, "pomf-tiny-${pomfVersion}.gz")
  outputs.file(outputFile)
  doLast {
    logger.lifecycle(":generating tiny mappings")

    String[] args = [
            mergedFile.getAbsolutePath(),
            mappingsDir.getAbsolutePath(),
            "mappings.tiny",
            "mojang",
            "pomf"
    ]

    new CommandTinyify().run(args)

    logger.lifecycle(":compressing tiny mappings")

    def buffer = new byte[1024]
    def fileOutputStream = new FileOutputStream(outputFile)
    def outputStream = new GZIPOutputStream(fileOutputStream)
    def inputFile = new File("mappings.tiny")
    def fileInputStream = new FileInputStream(inputFile)

    def length
    while ((length = fileInputStream.read(buffer)) > 0) {
      outputStream.write(buffer, 0, length)
    }

    fileInputStream.close()
    outputStream.finish()
    outputStream.close()
    inputFile.delete()
  }
}

tasks.build.dependsOn "buildTiny"
